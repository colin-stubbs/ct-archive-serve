# Feature Specification: ct-archive-serve (Static CT archive HTTP server)

**Feature Branch**: `001-ct-archive-serve`  
**Created**: 2026-01-20  
**Status**: Draft  
**Input**: User description: "create an additional CT log tool named \"ct-archive-serve\" which will function as a HTTP server and serve static content from within .zip files generated by photocamera archiver (https://github.com/FiloSottile/sunlight/blob/push-wuyvknmplxqr/cmd/photocamera-archiver/photocamera.go)"

## Clarifications

### Session 2026-01-20

- Q: How is `<log>` derived from discovered archive folder names? → A: `CT_ARCHIVE_FOLDER_PATTERN` MUST be of the form `<prefix>*` (a literal prefix followed by a single trailing `*`, default `ct_*`). `<log>` is the archive folder name with the `<prefix>` removed (e.g., for `CT_ARCHIVE_FOLDER_PATTERN=ct_*` → `<prefix>=ct_`, folder `ct_digicert_nessie2022` maps to `<log>=digicert_nessie2022`). If `CT_ARCHIVE_FOLDER_PATTERN` is not of the supported `<prefix>*` form, `ct-archive-serve` MUST fail startup with an invalid configuration error.
- Q: Should `ct-archive-serve` expose a log list endpoint for discovered archived logs? → A: Yes—`ct-archive-serve` must serve `GET /monitor.json` (`application/json`) and periodically regenerate it by extracting `log.v3.json` from each discovered log folder’s `000.zip`.
- Q: How is `has_issuers` determined for each `/monitor.json` `tiled_logs[]` entry? → A: `has_issuers=true` iff the discovered log folder’s `000.zip` contains at least one zip entry whose name begins with `issuer/`; otherwise `has_issuers=false`.
- Q: How should `Content-Type` be set on responses? → A: Use the most appropriate `Content-Type` for the served asset (e.g., `.json` → `application/json`; `/checkpoint` → `text/plain; charset=utf-8`; tiles → `application/octet-stream`; issuers → `application/pkix-cert`).

### Session 2026-01-21

- Q: What is the request logging policy for successful responses? → A: `ct-archive-serve` logs HTTP requests to stdout/stderr, but successful requests (HTTP 2xx) MUST only be logged when verbose mode is enabled via `-v|--verbose`.
- Q: What linting and security checks are required for ct-archive-serve? → A: `ct-archive-serve` uses `golangci-lint` for linting and basic Go code security checks; it uses `trivy` and `govulncheck` for additional code security evaluation.
- Q: What codebase/libraries must ct-archive-serve use for Static CT interactions? → A: `ct-archive-serve` MUST be implemented independently in this repository (no reuse of internal codebases as a dependency). It should use standard Go libraries where possible, and for Static CT / C2SP file-hierarchy interactions may use `filippo.io/sunlight` or `google/certificate-transparency-go` (or its own independent implementation).
- Q: How is ct-archive-serve built and distributed? → A: The project is built in public on GitHub; GitHub Actions CI pipelines are used to validate/test/build; successful builds publish a container image to GitHub Container Registry (GHCR).
- Q: What operational “quick run” artifact must be provided for container usage? → A: The repo MUST include a `compose.yml` that demonstrates running `ct-archive-serve` via `docker compose` or `podman compose`; `README.md` MUST document container-based operation.
- Q: What are the container runtime defaults? → A: The container MUST run as `nobody/nogroup` and listen on TCP/8080 by default. Operators MAY publish host TCP/80 to container TCP/8080 (e.g. `-p 80:8080`).
- Q: What data integrity verification is required when serving from torrent-downloaded zip parts? → A: `ct-archive-serve` only verifies `.zip` integrity (not Merkle/inclusion proofs). If a required zip part fails basic zip integrity checks (often because it is still downloading), the request MUST return HTTP `503` (temporarily unavailable). The server MUST cache zip integrity results in-memory: a permanent “passed” set (until read failures evict entries) and a “failed” set with TTL (default 5 minutes) before re-testing.

## User Scenarios & Testing *(mandatory)*

<!--
  IMPORTANT: User stories should be PRIORITIZED as user journeys ordered by importance.
  Each user story/journey must be INDEPENDENTLY TESTABLE - meaning if you implement just ONE of them,
  you should still have a viable MVP (Minimum Viable Product) that delivers value.
  
  Assign priorities (P1, P2, P3, etc.) to each story, where P1 is the most critical.
  Think of each story as a standalone slice of functionality that can be:
  - Developed independently
  - Tested independently
  - Deployed independently
  - Demonstrated to users independently
-->

### User Story 1 - Discover archived logs via monitor.json (Priority: P1)

A user downloads archived CT logs via torrents (e.g., from the `torrents.rss` feed in [geomys/ct-archive](https://github.com/geomys/ct-archive)) into a directory where each archive is stored as `ct_<LOG_NAME>/NNN.zip` parts. The user wants a single JSON endpoint that lists all discovered archived Static-CT logs so other tools (like `ctlogdaemon`) can automatically discover and consume them **without unzipping the archives**.

**Why this priority**: It enables automated discovery and removes the need to manually curate log list JSON when archives change.

**Independent Test**: Start `ct-archive-serve` with a `CT_ARCHIVE_PATH` containing multiple `ct_*` folders (as produced by a torrent client) with `000.zip`; `GET /monitor.json` returns `200` with `Content-Type: application/json` and includes one `tiled_logs` entry per discovered log, derived from each `000.zip`’s `log.v3.json`.

**Acceptance Scenarios**:

1. **Given** a CT archive path with multiple discovered log folders each containing `000.zip` with `log.v3.json`, **When** a client requests `GET /monitor.json`, **Then** the server responds `200` with `Content-Type: application/json` and a JSON document listing those logs.
2. **Given** a CT archive path where `/monitor.json` refresh cannot succeed (e.g., no valid `000.zip` + `log.v3.json`), **When** a client requests `GET /monitor.json`, **Then** the server responds `503` (temporarily unavailable) until a subsequent refresh succeeds (see `FR-006` refresh failure behavior).

---

### User Story 2 - Serve Static-CT assets from an archive directory (Priority: P1)

A user has a directory containing multiple archived logs under `CT_ARCHIVE_PATH` that were downloaded via torrents (each log as a folder like `ct_<LOG_NAME>/` containing `000.zip`, `001.zip`, etc.) and wants to expose the Static-CT monitoring endpoints over HTTP so existing clients can read all required Static-CT assets **directly from the zip parts** without unpacking the archive.

**Why this priority**: This is the core value of `ct-archive-serve`: serving the archived Static-CT log namespace over HTTP.

**Independent Test**: Start `ct-archive-serve` with an archive directory; a client can fetch the checkpoint, at least one hash tile, at least one data tile, and at least one issuer (when present), each returning byte-for-byte match with the archived entry and correct `Content-Type`.

**Acceptance Scenarios**:

1. **Given** an archive directory containing at least one zip with a `checkpoint` entry, **When** a client requests `GET /<log>/checkpoint`, **Then** the server responds `200` with `Content-Type: text/plain; charset=utf-8` and the checkpoint body bytes; otherwise `404` if missing.
2. **Given** an archive directory containing tiles, **When** a client requests an existing tile path under `GET /<log>/tile/<L>/<N>[.p/<W>]`, **Then** the server responds `200` with `Content-Type: application/octet-stream` and the tile bytes; otherwise `404` if missing/invalid.
3. **Given** an archive directory containing data tile entries, **When** a client requests `GET /<log>/tile/data/<N>[.p/<W>]`, **Then** the server responds `200` with `Content-Type: application/octet-stream` and the data tile bytes; otherwise `404` if missing/invalid.
4. **Given** an archive directory containing issuer entries, **When** a client requests `GET /<log>/issuer/<fingerprint>`, **Then** the server responds `200` with `Content-Type: application/pkix-cert` and the issuer DER bytes; otherwise `404` if missing/invalid.

### Edge Cases

- **Invalid paths**: Requests containing `..` or other traversal attempts MUST NOT escape the archive namespace (respond `404`).
- **Invalid tile encoding**: Requests with invalid `<L>`, invalid tile-index encoding, or invalid partial width MUST respond `404`.
  - `<L>` MUST be a base-10 integer in the inclusive range 0..255.
  - For `.p/<W>` requests, `<W>` MUST be a base-10 integer in the inclusive range 1..255 (full tiles use the non-`.p/` form).
- **Invalid issuer fingerprint**: For `/<log>/issuer/<fingerprint>`, `<fingerprint>` MUST be a non-empty lowercase hex string (`0-9a-f`). Any other form (including uppercase hex) MUST respond `404`.
- **Missing archive zips**: If the archive directory is missing required zip(s) for a given request, the server MUST respond `404`.
- **Zip part temporarily unavailable**: If the required zip part exists on disk but fails basic zip integrity checks (e.g., because it is still downloading), the server MUST respond `503` for requests that require that zip part (see `FR-013`).
- **Right-edge partial tiles**: For requests that include `.p/<W>`, `ct-archive-serve` MUST treat the path as a **literal archive entry path** and MUST NOT attempt to synthesize or rewrite tiles based on checkpoint tree size. The server returns `200` if and only if the corresponding zip entry exists; otherwise `404` (consistent with missing content).

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: `ct-archive-serve` MUST run as an HTTP server using Go’s standard library `net/http` (request parsing/routing/server) and listen on TCP/8080 by default. Non-standard-library packages MAY be used for:
  - metrics and structured logging
  - Static-CT / C2SP (tiled log) file-hierarchy interactions, where doing so materially reduces implementation risk (see `NFR-012`)
  - By default, the server SHOULD listen on `:8080` (all interfaces) unless constrained by the deployment environment.
- **FR-002**: `ct-archive-serve` MUST serve these paths with appropriate `Content-Type`:
  - `GET /monitor.json` → `application/json`
  - `GET /metrics` → `text/plain; version=0.0.4; charset=utf-8`
  - `GET /<log>/checkpoint` → `text/plain; charset=utf-8`
  - `GET /<log>/log.v3.json` → `application/json`
  - `GET /<log>/issuer/<fingerprint>` → `application/pkix-cert`
  - `GET /<log>/tile/<L>/<N>[.p/<W>]` → `application/octet-stream`
  - `GET /<log>/tile/data/<N>[.p/<W>]` → `application/octet-stream`
  Additionally, when serving a file-like asset, `ct-archive-serve` MUST set `Content-Type` appropriately based on the asset being served, including:
  - any `*.json` response as `application/json`
  - any `/checkpoint` response as `text/plain; charset=utf-8`
  - any tile response as `application/octet-stream`
  - any issuer response as `application/pkix-cert`
- **FR-002a**: HTTP method policy:
  - For all supported endpoints, `ct-archive-serve` MUST support `GET` and `HEAD`.
  - For `HEAD`, the server MUST behave as for `GET` but MUST NOT include a response body.
  - For any other HTTP method targeting a supported route, the server MUST respond `405` and include `Allow: GET, HEAD`.
  - For unknown/unsupported routes, the server MUST respond `404` regardless of method.
- **FR-003**: `ct-archive-serve` MUST support serving multiple archived CT logs from subfolders under `CT_ARCHIVE_PATH` (default: `/var/log/ct/archive`) filtered by `CT_ARCHIVE_FOLDER_PATTERN` (default: `ct_*`).
  - Within each discovered archive folder, `ct-archive-serve` MUST consider zip parts named `NNN.zip` where `NNN` is a 3-digit decimal number (e.g., `000.zip`, `001.zip`, …). `000.zip` is required for `/monitor.json` generation per `FR-006`.
- **FR-003a**: `ct-archive-serve` MUST derive the request `<log>` path segment from the discovered archive folder name by stripping a configured prefix. `CT_ARCHIVE_FOLDER_PATTERN` MUST be of the form `<prefix>*` (literal prefix followed by a single trailing `*`), and `ct-archive-serve` MUST strip exactly `<prefix>` from the folder name to produce `<log>`. If `CT_ARCHIVE_FOLDER_PATTERN` is not of the supported `<prefix>*` form, `ct-archive-serve` MUST fail startup with an invalid configuration error.
- **FR-003b**: `<log>` collision handling: If two or more discovered archive folders map to the same `<log>` after applying the `CT_ARCHIVE_FOLDER_PATTERN` prefix strip (`FR-003a`), `ct-archive-serve` MUST fail startup with an invalid configuration error. The error message SHOULD include the colliding folder names to aid remediation.
- **FR-004**: `ct-archive-serve` MUST use environment variables to configure all aspects of operation, with documented defaults. Environment variables configure runtime behavior; CLI flags are limited to help output and logging verbosity/debug only.
- **FR-005**: `ct-archive-serve` MUST support `-h|--help|-d|--debug|-v|--verbose` CLI arguments to modify operation (help and logging).
- **FR-006**: `ct-archive-serve` MUST generate and periodically refresh `GET /monitor.json` by extracting `log.v3.json` from `000.zip` in each discovered archive folder. The generated list MUST use `tiled_logs` entries compatible with common CT log list v3 consumers.
  - When serving `GET /monitor.json`, `ct-archive-serve` MUST set each entry’s `submission_url` and `monitoring_url` to the request’s derived “public base URL” plus `/<log>`.
  - The “public base URL” MUST be derived from the incoming HTTP request (not an environment variable):
    - `ct-archive-serve` MUST treat `X-Forwarded-*` headers as **untrusted by default**. It MUST only use `X-Forwarded-Host` and `X-Forwarded-Proto` when the request’s source IP is trusted per `CT_HTTP_TRUSTED_SOURCES` (see `FR-012`).
    - The request source IP MUST be derived from the TCP peer address (`net/http` `RemoteAddr`, host portion of `IP:port`).
    - **host**:
      - If the request source IP is trusted (per `CT_HTTP_TRUSTED_SOURCES`), use `X-Forwarded-Host` if present, otherwise use `Host`.
      - If the request source IP is not trusted, ignore `X-Forwarded-Host` and use `Host`.
      - If the chosen header value contains a comma-separated list, split on `,`, trim ASCII whitespace on each element, and use the first non-empty element.
    - **scheme**:
      - If the request source IP is trusted (per `CT_HTTP_TRUSTED_SOURCES`), use `X-Forwarded-Proto` if present, otherwise `http` (note: `ct-archive-serve` does not terminate TLS).
      - If the request source IP is not trusted, ignore `X-Forwarded-Proto` and use `http`.
      - If the chosen header value contains a comma-separated list, split on `,`, trim ASCII whitespace on each element, and use the first non-empty element.
      - The resulting scheme SHOULD be lowercased for URL construction.
    - Construct `publicBaseURL = "<scheme>://<host>"` and then `submission_url = publicBaseURL + "/<log>"`, `monitoring_url = publicBaseURL + "/<log>"`
  - The `/monitor.json` response MUST be compatible with the CT log list v3 JSON schema used by Static-CT tooling. Minimum required structure:
    - `version` MUST be `"3.0"`
    - `operators` MUST contain exactly one operator object with:
      - `name` = `"ct-archive-serve"`
      - `email` = `[]`
      - `logs` = `[]`
      - `tiled_logs` populated from discovered archive folders (one entry per folder with a valid `000.zip` → `log.v3.json`)
      - `tiled_logs` MUST be sorted deterministically by `<log>` in ascending ASCII lexicographic order (where `<log>` is derived from the archive folder name per `FR-003a`)
    - `log_list_timestamp` SHOULD be set to the time the current snapshot was generated/refreshed
  - **Refresh failure behavior**:
    - If the most recent refresh attempt fails for any reason (e.g., because a `000.zip` is temporarily unreadable or `log.v3.json` parsing fails), `ct-archive-serve` MUST respond to `GET /monitor.json` with HTTP `503` (temporarily unavailable), and SHOULD log an error describing the refresh failure.
    - When responding `503`, the server SHOULD return `Content-Type: application/json` with a small error body (e.g., `{"error":"temporarily unavailable"}`) rather than a log list v3 document.
    - Once a subsequent refresh attempt succeeds, `ct-archive-serve` MUST resume serving `200` with the newly generated snapshot.
    - `ct-archive-serve` SHOULD attempt an initial refresh at startup and then refresh periodically on `CT_MONITOR_JSON_REFRESH_INTERVAL`; refresh work MUST NOT occur on the request hot path.

  Example minimal shape (illustrative only; values are placeholders — fields within each `tiled_logs[]` entry are sourced from `log.v3.json` and then adjusted per requirements):

  ```json
  {
    "version": "3.0",
    "log_list_timestamp": "2026-01-21T00:00:00Z",
    "operators": [
      {
        "name": "ct-archive-serve",
        "email": [],
        "logs": [],
        "tiled_logs": [
          {
            "description": "Example Log",
            "log_id": "<base64 log_id>",
            "key": "<base64 public key>",
            "mmd": 86400,
            "log_type": "prod",
            "state": {},
            "submission_url": "https://ct.example/example_log_2024",
            "monitoring_url": "https://ct.example/example_log_2024",
            "has_issuers": true
          }
        ]
      }
    ]
  }
  ```
- **FR-006b**: For each generated `tiled_logs[]` entry, `ct-archive-serve` MUST ensure the entry is valid for common log list v3 consumers: it MUST provide either `url` (RFC6962) OR (`submission_url` + `monitoring_url`) (static-ct-api), but MUST NOT provide both. For archives, the server MUST publish static-ct-api URLs and therefore MUST NOT include `url` in the generated `tiled_logs[]` entries.
- **FR-006a**: For each generated `tiled_logs[]` entry, `ct-archive-serve` MUST set `has_issuers=true` if and only if the corresponding archive folder’s `000.zip` contains one or more entries under `issuer/` (determined from zip metadata; no full-zip decompression).
- **FR-007**: `ct-archive-serve` MUST provide environment variables to control `monitor.json` generation, including:
  - `CT_MONITOR_JSON_REFRESH_INTERVAL` (default: `5m`)
- **FR-008**: `ct-archive-serve` MUST map requested tile paths to the correct subtree zip part according to the `photocamera-archiver` subtree layout:
  - For hash tiles, a tile at level \(L\) and index \(N\) has \(leafStart = N \cdot 256^{L+1}\).
  - `photocamera-archiver` splits the log by level-2 tiles, each spanning \(256^3\) leaves, so for requests where \(L \le 2\) (and for data tiles), the subtree zip index MUST be derived as:
    - \(zipIndex = \lfloor leafStart / 256^3 \rfloor\)
    - equivalently:
      - for data tiles (`tile/data/<N>`): `zipIndex = N / 65536`
      - for level 0 tiles: `zipIndex = N / 65536`
      - for level 1 tiles: `zipIndex = N / 256`
      - for level 2 tiles: `zipIndex = N`
  - For \(L \ge 3\), `photocamera-archiver` MAY include those tiles in every zip, so `ct-archive-serve` MUST serve them from a preferred “shared metadata” zip (prefer `000.zip` when present; otherwise the lowest available zip part).
- **FR-008a**: Tile indices in request paths MUST use the standard tlog "groups-of-three" decimal encoding (to avoid huge single directories and to match common Static-CT clients):
  - For both hash tiles and data tiles, `<N>` in the request path encodes a non-negative integer tile index \(N\) using one or more path segments.
  - **Encoding**: Convert \(N\) to an unsigned decimal string, left-pad with `0` so the total length is a multiple of 3 digits, then split into 3-digit groups separated by `/`.
    - Examples: \(N=0\) -> `000`; \(N=1\) -> `001`; \(N=1234\) -> `001/234`; \(N=1234567\) -> `001/234/567`
  - **Full tile request forms**:
    - Hash: `GET /<log>/tile/<L>/<N>` where `<N>` is the multi-segment groups-of-three path
    - Data: `GET /<log>/tile/data/<N>` where `<N>` is the multi-segment groups-of-three path
  - **Partial tile request forms**: The `.p/<W>` suffix applies to the final 3-digit `<N>` segment:
    - Hash: `GET /<log>/tile/<L>/<N>.p/<W>`
    - Data: `GET /<log>/tile/data/<N>.p/<W>`
  - **Decoding/validation**: Each `<N>` path segment MUST be exactly 3 ASCII digits (`0-9`). Any other form MUST be rejected as invalid and return `404` (see Edge Cases).
- **FR-009**: `ct-archive-serve` MUST return `404` for missing entries and invalid paths, and MUST NOT allow path traversal.
  - For supported endpoints under `/<log>/...`, `ct-archive-serve` MUST treat the path suffix after `/<log>/` as the **zip entry name** to be served (relative to the zip root), without rewriting or synthesis. Examples:
    - `GET /<log>/checkpoint` serves zip entry `checkpoint`
    - `GET /<log>/log.v3.json` serves zip entry `log.v3.json`
    - `GET /<log>/issuer/<fingerprint>` serves zip entry `issuer/<fingerprint>`
    - `GET /<log>/tile/<L>/<N>[.p/<W>]` serves zip entry `tile/<L>/<N>[.p/<W>]`
    - `GET /<log>/tile/data/<N>[.p/<W>]` serves zip entry `tile/data/<N>[.p/<W>]`
- **FR-009a**: For requests that require reading a specific zip part, if that zip part exists but fails basic zip integrity checks, `ct-archive-serve` MUST return `503` (temporarily unavailable) rather than `404` (see `FR-013`).
- **FR-010**: `ct-archive-serve` SHOULD be compatible with Static-CT (C2SP/tiled) client implementations when configured with the server as their monitoring prefix.
- **FR-011**: `ct-archive-serve` MUST provide environment variables to tune high-load performance (bounded resource usage), including:
  - `CT_ZIP_CACHE_MAX_OPEN` (default: `256`) — maximum number of simultaneously-open zip parts across all logs
  - `CT_ARCHIVE_REFRESH_INTERVAL` (default: `1m`) — how frequently to refresh the on-disk archive folder/zip-part index (must not run on the request hot path)
- **FR-013**: Zip integrity verification and temporary unavailability handling:
  - `ct-archive-serve` MUST treat archive zip parts as potentially incomplete (e.g., during torrent downloads) and MUST perform **basic zip integrity checks** before using a zip part to serve content.
  - Basic zip integrity checks MUST be limited to establishing that the zip file is structurally valid for serving via Go's `archive/zip`:
    - The central directory/EOCD MUST be readable (e.g., `zip.OpenReader` succeeds).
    - Local file headers MUST be structurally valid for entries referenced by the central directory (e.g., iterate `r.File` and `Open()`/`Close()` each entry **without reading entry bodies**), to validate offsets/signatures for likely-truncated downloads.
    - These checks MUST NOT require reading or buffering entire entry payloads; the server MUST only read zip metadata/headers needed to establish structural validity.
  - The server MUST NOT attempt Merkle/inclusion verification as part of serving.
  - If a request requires a zip part and that zip part fails basic zip integrity checks, the server MUST return HTTP `503` to indicate the requested content is temporarily unavailable.
  - To avoid repeated integrity work, the server MUST maintain in-memory integrity caches:
    - A **passed** set of zip parts that have passed integrity checks. Entries MUST be kept for the lifetime of the process and MUST only be removed if subsequent open/read attempts for that zip part fail (which MUST be handled gracefully).
    - A **failed** set of zip parts that have failed integrity checks, with an expiry. Entries MUST expire after `CT_ZIP_INTEGRITY_FAIL_TTL` (default: `5m`) to allow re-testing once a download completes.
  - `CT_ZIP_INTEGRITY_FAIL_TTL` MUST be configurable via environment variable. Invalid values MUST fail startup with an invalid configuration error.
- **FR-012**: `ct-archive-serve` MUST configure the underlying `net/http` server with safe timeouts and header limits to prevent resource exhaustion under slow/abusive clients. These MUST be configurable via environment variables with documented defaults, including:
  - `CT_HTTP_READ_HEADER_TIMEOUT` (default: `5s`)
  - `CT_HTTP_IDLE_TIMEOUT` (default: `60s`)
  - `CT_HTTP_MAX_HEADER_BYTES` (default: `8192`)
  - `CT_HTTP_WRITE_TIMEOUT` (default: `0` meaning “no explicit write timeout”)
  - `CT_HTTP_READ_TIMEOUT` (default: `0` meaning “no explicit read timeout”)
  - `CT_HTTP_TRUSTED_SOURCES` (default: empty)
    - CSV list of trusted request source IPs and/or CIDR ranges (e.g., `127.0.0.1,10.0.0.0/8,192.168.1.10/32`)
    - When empty/unset, **no sources are trusted** and `X-Forwarded-Host`/`X-Forwarded-Proto` MUST be ignored for `/monitor.json` URL formation (but MUST still be logged; see `NFR-010`).
    - Invalid entries MUST fail startup with an invalid configuration error.

### Non-Functional Requirements

- **NFR-001**: The server MUST be designed to perform under extreme load such that scaling is primarily constrained by hardware (CPU, memory bandwidth, disk throughput), not avoidable software overhead. In particular, the server MUST:
  - avoid per-request directory scanning or archive discovery (use an in-memory index)
  - avoid repeated central-directory parsing for hot zip parts (use cached zip entry indices)
  - avoid global lock contention on request hot paths
- **NFR-002**: The server MUST limit responses to files within the archive set and MUST NOT expose the filesystem beyond the archive directory.
- **NFR-003**: The server MUST open and read `.zip` parts in a seekable (random-access) manner so that serving a single zip entry does not require loading or decompressing the entire `.zip` file into memory; the server MAY read zip metadata (central directory) and MUST only decompress the requested entry data.
- **NFR-004**: The implementation MUST use Go’s standard library `archive/zip` in a random-access mode (e.g., `zip.OpenReader` or `zip.NewReader` over an `io.ReaderAt`) so the server can locate a specific entry via the central directory and stream-decompress only that entry.
- **NFR-005**: The server MUST support high concurrency safely. Shared caches and indices MUST be concurrency-safe and SHOULD minimize contention (e.g., sharding by log/zip part).
- **NFR-006**: The server MUST bound resource usage for its performance optimizations:
  - the number of open zip parts MUST be capped (`CT_ZIP_CACHE_MAX_OPEN`)
  - cached indices and open-file state MUST be evictable (e.g., LRU) to handle large working sets
- **NFR-007**: The server MUST stream responses and MUST NOT buffer full zip entries into memory (except for small cached responses like `monitor.json`).
- **NFR-008**: The server MUST be safe to deploy behind a reverse proxy and MUST NOT attempt to enforce transport/security controls that are expected at the reverse proxy boundary:
  - No TLS termination (plain HTTP only; default listen port 8080)
  - No in-process rate limiting (rate limiting is expected to be performed by the reverse proxy)
  - No hostname or transport validation (the server treats `Host`/`X-Forwarded-*` as opaque inputs for `/monitor.json` URL formation)
  - Production deployments MUST place `ct-archive-serve` behind a reverse proxy that enforces TLS and rate limiting and forwards `X-Forwarded-*` as required for `/monitor.json` URL formation.
  - When using a reverse proxy, deployments SHOULD set `CT_HTTP_TRUSTED_SOURCES` to the proxy’s source IPs/CIDRs so `X-Forwarded-*` is only honored from that boundary.
- **NFR-009**: `ct-archive-serve` request/serving Prometheus metrics MUST be low-cardinality to avoid metric blowout:
  - Request/serving metrics MUST be limited to (a) `/monitor.json` and (b) per-`<log>` aggregates for all `/<log>/...` serving combined
  - Request/serving metrics MUST NOT be labeled by full request path, tile coordinates, endpoint name, or status code
- **NFR-010**: Logs MUST be structured (JSON) and suitable for production operations behind a reverse proxy:
  - The server MUST log errors with clear context (including request path and derived `<log>` when applicable) without leaking secrets
  - Verbosity MUST be controllable via `-v/--verbose` and `-d/--debug`
  - Logging MUST be written to process stdout/stderr (for container/daemon operation):
    - INFO/WARN/DEBUG logs SHOULD go to stdout; ERROR and higher SHOULD go to stderr
    - HTTP request logs MUST be emitted as structured JSON and include at least: request path, derived `<log>` (when applicable), selected zip part (when applicable), status code, and duration
    - HTTP request logs MUST include `X-Forwarded-Host` and `X-Forwarded-Proto` values when present, even when ignored for URL formation due to untrusted source IPs
    - HTTP request logs for successful responses (HTTP 2xx) MUST be emitted only when `-v/--verbose` is enabled; non-2xx responses MUST be logged regardless of `-v`
- **NFR-011**: `ct-archive-serve` MUST meet repository code-quality and security gates for Go code:
  - `golangci-lint` MUST pass for `ct-archive-serve` changes (linting + basic security checks configured via `.golangci.yml`)
  - `govulncheck` MUST be run as part of security evaluation for `ct-archive-serve` changes
  - `trivy` MUST be run as part of security evaluation for `ct-archive-serve` changes
  - Repository tooling may provide these checks via `make lint` and `make security`
- **NFR-012**: `ct-archive-serve` MUST be implemented independently in this repository (no reuse of internal codebases as a dependency):
  - The implementation SHOULD use Go’s standard library where possible.
  - For Static-CT / C2SP file-hierarchy interactions, the implementation MAY use upstream libraries such as [`google/certificate-transparency-go`](https://github.com/google/certificate-transparency-go) or `filippo.io/sunlight`, or implement the required logic itself.
- **NFR-013**: Build and release workflow MUST be GitHub-native and produce container artifacts:
  - The repository MUST be public on GitHub.
  - CI MUST run on GitHub Actions and MUST at minimum run `go test ./...` and linting for all pull requests.
  - The build pipeline MUST produce a container image and, on successful builds for the default branch and/or tags, MUST publish that image to GHCR (`ghcr.io/...`).
- **NFR-014**: The repository MUST provide container operation examples:
  - A repo-root `compose.yml` MUST be provided as an example for running `ct-archive-serve` via `docker compose` or `podman compose`.
  - `README.md` MUST explain how to operate `ct-archive-serve` using containers (including `docker run` and compose-based examples).
- **NFR-015**: The container image defaults MUST be safe-by-default:
  - The container image MUST run as `nobody/nogroup` (non-root).
  - The container image MUST listen on TCP/8080 by default.
  - Operators MAY publish host TCP/80 to container TCP/8080 (e.g. `-p 80:8080`).

### Key Entities *(include if feature involves data)*

- **Archive directory**: A filesystem directory containing per-log archive folders, each containing `000.zip`, `001.zip`, … generated by `photocamera-archiver`.
- **Zip entry**: A file within a subtree zip (e.g., `checkpoint`, `tile/0/000`, `tile/data/000`, `issuer/<hex>`).
- **Tile request**: A request for a Static-CT tile path, including tile type (hash/data), level, index, and optional partial width.
- **Monitor list**: The `GET /monitor.json` JSON document listing discovered logs under `operators[].tiled_logs[]`.

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: A test client can fetch `GET /<log>/checkpoint` and receive a valid checkpoint payload (byte-for-byte match with the archived entry).
- **SC-002**: A test client can fetch at least one hash tile and one data tile from the archive set and receive the exact bytes stored in the zip entries.
- **SC-003**: Requests for invalid or missing paths reliably return `404` without exposing filesystem contents.
- **SC-004**: A test client can fetch `GET /monitor.json` and receive a JSON document with one `tiled_logs` entry per discovered archive folder (derived from its `000.zip` → `log.v3.json`), with `submission_url` and `monitoring_url` pointing at `<publicBaseURL>/<log>` where `<publicBaseURL>` is derived from the incoming request (per `FR-006`).
- **SC-005**: In `GET /monitor.json`, each `tiled_logs[].has_issuers` value matches whether that log’s `000.zip` contains any `issuer/` entries.
- **SC-006**: Under a large-working-set access pattern (requests spread across many zip parts), profiling/benchmarks demonstrate that request-path CPU time is dominated by zip entry decompression + disk reads + network writes, and not by avoidable overhead such as archive rescans, repeated central-directory parsing, or lock contention. At minimum, the performance validation MUST demonstrate:
  - archive discovery / directory walking does not occur on the request hot path (only in startup and the periodic refresh loop)
  - repeated zip central-directory parsing is amortized by caching for hot zip parts (cache hit behavior is observable in metrics/logs or benchmark instrumentation)
  - no single global lock dominates request-path CPU time under concurrency (verified via Go profiles such as mutex/CPU profiles)
